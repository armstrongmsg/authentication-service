package org.fogbowcloud.as.core.tokengenerator;

import org.apache.log4j.Logger;
import org.fogbowcloud.as.common.constants.FogbowConstants;
import org.fogbowcloud.as.common.exceptions.FatalErrorException;
import org.fogbowcloud.as.common.util.ServiceAsymmetricKeysHolder;
import org.fogbowcloud.as.common.util.RSAUtil;
import org.fogbowcloud.as.common.exceptions.FogbowException;
import org.fogbowcloud.as.common.exceptions.UnexpectedException;
import org.fogbowcloud.as.common.util.TokenValueProtector;
import org.fogbowcloud.as.core.constants.Messages;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Date;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class TokenGeneratorPluginDecorator {
    // Adds expiration time and signs tokens generated by the specific TokenGeneratorPlugins
    private static final Logger LOGGER = Logger.getLogger(TokenGeneratorPluginDecorator.class);

    private static final long EXPIRATION_INTERVAL = TimeUnit.DAYS.toMillis(1); // One day

    private TokenGeneratorPlugin embeddedPlugin;

    private RSAPrivateKey privateKey;

    public TokenGeneratorPluginDecorator(TokenGeneratorPlugin embeddedPlugin) {
        this.embeddedPlugin = embeddedPlugin;
        try {
            this.privateKey = ServiceAsymmetricKeysHolder.getInstance().getPrivateKey();
        } catch (IOException | GeneralSecurityException e) {
            throw new FatalErrorException(Messages.Fatal.ERROR_READING_PRIVATE_KEY_FILE, e);
        }
    }

    public String createTokenValue(Map<String, String> userCredentials, String publicKeyString)
            throws UnexpectedException, FogbowException {
        // The token generator plugin generates a raw token; the wrapper adds an expiration time,
        // a signature, and encrypts the token using the public key provided by the client.
        String tokenAttributes = this.embeddedPlugin.createTokenValue(userCredentials);
        String expirationTime = generateExpirationTime();
        String payload = tokenAttributes + FogbowConstants.PAYLOAD_SEPARATOR + expirationTime;
        String signature = null;
        try {
            signature = RSAUtil.sign(this.privateKey, payload);
            String signedUnprotectedToken = payload + FogbowConstants.TOKEN_SEPARATOR + signature;
            RSAPublicKey publicKey = RSAUtil.getPublicKeyFromString(publicKeyString);
            return TokenValueProtector.encrypt(publicKey, signedUnprotectedToken, FogbowConstants.TOKEN_STRING_SEPARATOR);
        } catch (UnsupportedEncodingException | GeneralSecurityException e) {
            throw new UnexpectedException();
        }
    }

    public TokenGeneratorPlugin getEmbeddedPlugin() {
        return this.embeddedPlugin;
    }

    private String generateExpirationTime() {
		Date expirationDate = new Date(getNow() + EXPIRATION_INTERVAL);
        String expirationTime = Long.toString(expirationDate.getTime());
		return expirationTime;
	}

    public long getNow() {
    	return System.currentTimeMillis();
    }
}
